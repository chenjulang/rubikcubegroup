正在阅读Adventures in group theory Rubiks cube,
    Merlins machine, and other mathematical toys (Joyner, David) --ok
看完第5章，--doing 1.一组魔方操作，最多重复操作1260次就可以还原，不多吧，操作为m = RU2D−1BD−1 。柯西定理有此话题更多的讨论。 --ok
还是得从书的第一页开始，不懂的举例子|然后要将关键定理用我们自己的理解记下来，不然会忘|跳过非魔方的部分--ok
|定理不一定要详细证明，但是名词一定要彻底理解，这样证明就只是一种技巧 ｜写记录的时候先写个总概括--ok

实在不懂的找gpt举例子：
1.
关键定理自我理解记录：
1.P (f ) :是一个矩阵，其中 f 是一个排列，举例；
    写成f=（2，1，3）， P(f)就是
   [[0 1 0]
    [1 0 0]
    [0 0 1]], 也就是第1行第2列，第2行第1列，第3行第3列，根据f来的，都是1，其他为0
2.Sn : 有时代表任意排列组成的集合，元素数量当然就是n!个
3.与有关的魔方引理lemma 3.2.3：r^−1sr复合操作，能直接修改首位位置，修改效果是直接通过r映射。
    举例：
    i是uf位置,j是uf位置
    有一个操作s效果是3循环：s:= uf → ul → ur → uf ,
    另一个操作r := F^2
    则：
    r^−1sr的效果是r(i)位置 → r(j)位置
    因为r(uf)= df,所以：
    df → ul → ur → df
4.对于排列f，f的order定义:使得 f^N = 1 > 0 的最小整数 N 称为 f 的阶数order
5.对于排列f，f是even或odd的，意思是：swap(f ) 是even或odd，也就是f的逆序数之和
    逆序数具体定义：
    定义 3.1.1. 让 f : 跟n → 跟n 是一个排列组合，让
    和f (i) = #{j > i | f (i) > f (j)}, 1 ≤ i ≤ n − 1.
    swap（f ) = 和f (1) + . . . + 和f (n − 1)
6.算法：生成所有排列的方式竟然如此简单 3.4
7.超级翻转游戏：只翻转所有棱块，其他角块和中心块不影响
8.Sn ：也可以叫做“对称群”，因为满足P87的四个属性：封闭+结合律+单位排列+逆排列
9.tips:从群的乘法表出发分析，可以很容易的定义和判别是否阿贝尔群，关于对角线对称。
10.由某个集合S生成的置换群G，定义是:由某个有限的集合S，S集合里面元素是一个个排列，定义一个G集合，
    里面元素是任意S里面的元素复合运算得到的结果（当然也是一个个排列）
11.魔方群：是一个置换群G，也叫做由Sx中的元素“生成”的置换群。
    X： 是魔方的 54 个面的集合，
    Sx：是一个排列的集合，让 R、L、U、D、F、B ∈ Sx 表示魔方的基本动作， R、L、U、D、F、B都是一个个排列
    置换群G = 〈R、L、U、D、F、B〉 ⊂ Sx 就称作魔方群
12.对于群G，群G的order，符号|G|表示： 群元素的数量。 魔方群的|G| = 2^27*3^14*5^3*7^2*11
13.对于群的元素g，g的order，符号ord(g)表示：使得g^m=1 的最小的m（如果m存在的话）.
    魔方群中最大order为元素m = RU2D−1BD−1，其order为1260
14.柯西定理，用来判断元素g，g满足order是某个数，这样的g，是否存在。
    因此可以判断魔方群中某个元素g,g符合order为某个值，能判断这样的g是否能存在。
15.对于群G，群G由一个元素生成的，称为循环的群。
16.对于群G，和G的子群H，这样的数|G|/|H|， 称为index ，符号记为[G:H]。
17.对于群G，G的center，中心：center是一个G的子群，里面的元素z，对于任意的群G里面的元素g，z ∗ g = g ∗ z，换句话说可以左乘+右乘相等的
    具体集合定义为Z（G） = {z ∈ G | z ∗ g = g ∗ z，对于所有 g ∈ G}。
    trivial center：当子群Z（G）只有一个元素时，这个元素也就是最普通的单位元时，就称作平凡的。
    借此机会，对于群G，可以定义commutative：群G，如果G = Z（G），即G等于G的这个子群，则G称作交换的。
18.对于魔方群G，G是S₄₈（一个由48元素的任意排列，这样的排列为元素组成的群）的一个子群。
19.对于魔方群G，G的center就是集合Z(G) = {1, superflip}
    superflip已被人们所知道的一个是：
    superflip = R · L · F · B · U · D · R · L · F · B · U · F 2 · M R ·
    ·F 2 · U −1 · MR 2
    R · B2 · MR −1
    R · B2 · U · MR 2
    R · D
    = R · L · F · B · U · D · R · L · F · B · U · F 2 · R−1 ·
    ·L · D2 · F −1 · R2 · L2 · D2 · R · L−1 ·
    ·F 2 · D · R2 · L2 · D (34 quarter turns)（它是34次转动的一组操作）
    （这里MR 指的是右中间切片顺时针旋转 90 度（从右边的面来看））
    而且已被证明，最小转动次数的superflip是一下这个：
    R, R−1 , L, L−1 , U, U −1 , D, D−1 , B, B−1 , F, F −1
20.

进度：P96/329



看完一二基本定理的证明后就看TW算法，书里面只有一页介绍，所以要看北师大老师的视频
然后再看这里项目的内容看看如何形式化，有哪些相关的
看看能否形式化出更多书里已看的定理，还有视频看到的算法
